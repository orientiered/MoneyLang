# Язык программирования Money++

English version (outdated) : [README](README_en.md)

Маленький язык программирования с фокусам на деньгах, написанный с нуля.

Реализован полный* процесс компиляции для x86_64 от текстового исходника до бинарного исполняемого файла без использования* сторонних программ.

*Стандартную библиотеку языка необходимо скомпилировать при помощи `nasm`.

## Содержание

1. [Синтаксис Money++](#синтаксис)
2. [Компиляция](#компиляция-и-использование)
3. [Фронтенд](#фронтенд)
3. [Обратный фронтенд](#обратный-фронтенд)
4. [Миддленд](#миддленд)
5. [Бекенд](#бекенд)
6. [Источники](#источники)

## Синтаксис

### Пример: подсчёт факториала заданного числа

[fact.mpp](examples/fact.mpp)

```
@ Создаём переменную - банковский счёт (единственный тип - вещественные числа)
Account a %

@ Объявляем функцию fact, которая принимает один аргумент - a
Transaction a -> fact ->
<
    @ К операторам сравнения, в которых есть =, добавляется ещё одно =
    @ Все численные константы должны заканчиваться $ или ₽.
    @ Все доллары будут переведены в рубли по курсу 35:1
    if a ==< 1₽ ->
        @ Возвращаем результат
        @ При компиляции можно включить налоговые сборы,
        @ тогда со всех возвращённых значений будет взято 20%
        Pay 1₽ %

    Account b %
    @ Пример рекурсии
    b = fact(a - 1₽) * a %

    Pay b %
>

@ Пополняем баланс счёта из стандартного ввода
Invest a %
@ Заказываем справку из банка о доходах в стандартный вывод
ShowBalance fact(a) %
```

Другие примеры можно посмотреть в папке [`examples`](examples/)

### EBNF

Здесь представлен синтаксис языка в формате, близком к EBNF ( расширенная форма Бэкуса-Наура). Подробнее о ней можно почитать, например, [здесь](https://ru.wikipedia.org/wiki/Расширенная_форма_Бэкуса_—_Наура#Примеры_конструкций)

```
Grammar::= [FunctionDecl | Block ]+ EOF
FunctionDecl::= "Transaction" IdChain "->" Identifier "->" Block
Block  ::= "<" Block+ ">" | Statement
Statement ::= [Input | Print | Pay | Text | VarDecl | FunctionCall | Assignment] % | If | While
Text   ::= "Txt"  '"'String'"'
If     ::= "if" Expr "->" Block Else?
Else   ::= "else" BLock
While  ::= "while" Expr "->" Block
Print  ::= "ShowBalance" Expr
Pay    ::= "Pay Expr
Input  ::= "Invest" Identifier
VarDecl ::= "Account" Identifier
Assignment ::= Identifier '=' Expr

Expr   ::=AddPr{ ['>''<' '>==' '==<' '===' '!=='] AddPr}*
AddPr  ::=MulPr{ ['+''-']  MulPr}*
MulPr  ::=PowPr{ ['*''/']  PowPr}*
PowPr  ::=Primary{ '^'  PowPr}?


//NOTE: IdChain and ExprChain are represented with GetIdOrExprChain
IdChain   ::= Identifier?[','Identifier]*
ExprChain ::= Expr?[','Expr]*

FunctionCall::= Identifier'('ExprChain')'
Primary::= '(' Expr ')' | FuncOper | FunctionCall | Identifier | Num

FuncOper   ::=["sin" "cos" "tg" "ctg" "ln"]'(' Expr ')'
Identifier ::=['a'-'z''_']+ ['a'-'z''_''0'-'9']*
String     ::=[^"]
Num    ::= [number][₽$]
```

## Компиляция и использование

**TLDR**:

```bash
    git clone https://github.com/orientiered/MoneyLang.git && \
    cd MoneyLang && \
    git clone -b macroChaos https://github.com/orientiered/Processor.git && \
    make all -j4 && \
    cd Processor && \
    make all BUILD=RELEASE -j4 && \
    cd ..
```

0.Клонируем репозитории

```bash
    git clone https://github.com/orientiered/MoneyLang.git
    cd MoneyLang
    git clone -b macroChaos https://github.com/orientiered/Processor.git
```

1. Компилируем части компилятора: фронтенд и бекенд

```bash
    make all
```
2. Компилируем процессор (не нужно, если компилируете для x86_64):

```bash
    cd Processor
    make all
    cd ..
```

3. Компилируем и запускаем вашу программу

```bash
    ./run.sh yourProgram.mpp
```

## Общая схема компиляции программы

<div style="text-align: center;">
    <img src=img/compilation_process.svg width=60%>
</div>

Все этапы компиляции описаны далее.

## Фронтенд

```bash
    ./front.out program.mpp -o program.ast
```

Фронтенд строит абстрактное синтаксическое дерево (AST) путём парсинга исходного файла методом рекурсивного спуска.

Сначала происходит лексический анализ: исходный файл разбивается на массив лексем, с которыми удобнее работать, чем с текстом.

Затем происходит рекурсивный спуск по правилам [EBNF](#ebnf). Из лексем строится дерево, которое затем сохраняется в файл для даленьшей обработки.

Формат AST в какой-то мере описан в массиве `ASTNames` в [Context.h](LangGlobals/include/Context.h). По факту это просто соответсвие между узлами дерева и строками в файле.

Кроме дерева в файле находится сигнатура, обозначающая версию и стандарт, а также **таблица имён**, которая содержит информацию о всех переменных и функциях.

## Обратный фронтенд

```bash
    ./front.out program.ast -1 -o program.mpp
```

При конвертации в AST практически не теряется информация об исходном коде. Это даёт возможность 'декомпилировать' AST обратно. Более того, декомпиляцию можно совершить в другой язык с таким же стандартом AST.

Такая трансляция одного языка в другой была протестирована с языком [crefr](https://github.com/crefr/language).

**Примечание:**на данный момент в дереве Money++ больше операторов (например, 'text'), поэтому стандарты совместимы не полностью. Стоит помнить о том, что AST не сохраняет комментарии из исходного кода.

## Миддленд

Эта стадия совершает простые оптимизации оптимизации над деревом, упрощая константные выражения и удаляя нейтральные операции, вроде 0 + x.

В данном проекте нет миддленда, но благодаря совместимости AST можно использовать миддленд, написанный [crefr's](https://github.com/crefr/language).

## Бекенд

```bash
    ./back.out program.ast -o program.asm
    # add --taxes to get tax on every function return
```

Задача бекенда - транслировать AST в ассемблер, либо в исполняемый файл.

Основная идея заключается в обратном обходе дерева (**post-order**): рекурсивно обходится левое поддерево, затем правое, затем текущий узел. Это позволяет перевести выражения из привычной **инфиксной** формы в **постфиксную**.

Этот вид нотации очень удобен для выполнения **стековых вычислений**: результаты выражений, посчитанных в левом и правом поддеревьях кладутся на стек. Оператор, лежащий в текущем узле, достаёт их со стека, совершает предписанное действие и кладёт результат обратно.


### Области видимости

Многие языки программирования позволяют объявлять переменные с одинаковыми названиями в разных областях видимости. Например:

```c
int x = 1;

if (...) {
    // область видимости условного оператора
    int x = 2; // Это уже другой x
}
```

Нормальные компиляторы обрабатывают это во фронтенде, создавая несколько записей в таблице имен. Выход из области видимости отслеживается при помощи поддержания стека всех видимых имён.

В компиляторе `Money++` эта задача оказалась возложена на бекенд.

### SPU

Это симулятор стекового процессора, поэтому всё довольно просто: во время обхода дерева в файл печатаются соответствующие ассемблерные команды.

### x86_64

Компиляция для x86_64 совершается в два с этапа.

1. Преобразование дерева в промежуточное представление - IR.
2. Трансляция IR в ассемблерный или в исполняемый файл

IR является звеном между AST и инструкциями процессора. На нём проще делать некоторые оптимизации. Хороший IR всё ещё является платформонезависимым, что позволяет применять целый класс оптимизаций для всех машин.

В данном проекте IR был сделан для стековых вычислений и представляет собой массив. Промежуточное представление похоже на ассемблер SPU.

Массив узлов IR транслируется в бинарный файл в 2 прохода: на первом проходе вычисляются адреса всех узлов. На втором узлы IR при помощи эмиттеров переводятся в инструкции x86_64.

## Elf

Чтобы операционная система смогла запустить полученную программу, сгенерированный машинный код нужно сохранить в специальном формате.

На таких операционных системах как Linux и MacOs есть единый формат - elf - executable and linkable format.

Для простейшего исполняемого файла elf будем использовать структуру, указанную на следующем рисунке:

<div style="text-align: center;">
    <img src=img/elf_structure.svg width=60%>
</div>

## Сравнение скорости SPU и x86_64

Проведём сравнение скорости выполенния программы, которая рекурсивно вычисляет 5! 5 миллионов раз.

Исходный файл на языке Money++: [stressTest.mpp](examples/stressTest.mpp)

Для тестирования воспользуемся утилитой `hypefine`:

```
  x86_64 benchmark
  Time (mean ± σ):     155.0 ms ±   5.4 ms    [User: 143.0 ms, System: 0.0 ms]
  Range (min … max):   147.0 ms … 169.0 ms    19 runs
```
```
  SPU benchmark
  Time (mean ± σ):      8.836 s ±  0.048 s    [User: 8.149 s, System: 0.002 s]
  Range (min … max):    8.757 s …  8.902 s    10 runs
```

На данном примере ускорение практически в 60 раз. Эта разница показывает, насколько большой разрыв между интерпретируемыми языками и компилируемыми.

## Известные баги

1. Блоки кода, не прикреплённые к условному оператору или к циклу обрабатываются фронтендом неправильно.

Пример:
```
<
    Account test %
    test = 1$ %
    <
        Account test2 %
    >
>
```

В синтаксическое дерево попадёт только объявление переменной `test`, остальное исчезает.

## Источники

1. Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2 Instruction Set Reference

